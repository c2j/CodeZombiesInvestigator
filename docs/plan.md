## 🚀 CZI 开发规划：分阶段路线图

| 阶段 | 名称 | 目标 / 核心产出 | 技术栈重心 |
| :--- | :--- | :--- | :--- |
| **0** | **架构奠基与环境设置** | 确认所有工具链可用性，构建项目骨架，实现多仓库代码统一拉取。 | Rust / Git |
| **1** | **图数据摄取核心 (Headless MVP)** | 实现代码解析、符号节点创建和核心依赖边（`CALLS`, `IMPORTS`）。能够生成可序列化的图结构。 | Rust (Tree-sitter, Petgraph, Tokio) |
| **2** | **语义链接与分析引擎 (The Investigator)** | 实现三大核心链路的语义链接，并完成可达性分析算法。输出标准化的僵尸代码报告。 | Rust (Petgraph Algorithms) |
| **3** | **Tauri 客户端与可视化 (The UI)** | 集成 Tauri IPC 桥接，构建前端可视化层，实现报告展示和基础路径查询。 | Tauri / Web UI (JS/TS), D3.js |
| **4** | **性能优化与规模化 (Scale & Polish)** | 优化内存，实现增量分析，加入用户体验改进和复杂的路径分析功能。 | Rust (Sled/bincode), NFR Testing |

***

## 1. 阶段零：架构奠基与环境设置 🛠️

**目标：** 确保所有高性能组件就位，并实现代码 I/O 的统一化。

| 任务编号 | 关键任务描述 (Deliverables) | 关联需求 |
| :--- | :--- | :--- |
| **0.1** | 搭建 Rust + Tokio 项目骨架，集成 **Tree-sitter** 依赖。 | NFR-T.1 |
| **0.2** | 定义 **Repository Config Model**，实现 **Repository Manager**：读取多仓库清单。 | FR-A.1, FR-A.2 |
| **0.3** | 实现 **Git I/O 层**：支持对配置仓库的异步 `shallow clone` 和 `fetch` 操作。 | NFR-P.2 |
| **0.4** | 实现 **虚拟文件系统抽象**：统一访问不同仓库的代码文件。 | FR-B.1 |

***

## 2. 阶段一：图数据摄取核心 (Headless MVP) ⚙️

**目标：** 实现基础图结构，能够解析 Java/JS 等语言的**直接调用**和**引入**关系。

| 任务编号 | 关键任务描述 (Deliverables) | 关联需求 |
| :--- | :--- | :--- |
| **1.1** | 实现 **`DependencyGraph`** 结构 (基于 `petgraph::DiGraph`) 和 **`SymbolIndex`** 映射。 | FR-B.1 |
| **1.2** | 实现 **并发解析器**：对所有文件并行执行 Tree-sitter AST 解析。 | FR-A.4 |
| **1.3** | 完成 **符号提取逻辑**：从 AST 中提取所有 `Function`, `Class` 等节点，并创建其 **唯一 ID**。 | FR-B.1 |
| **1.4** | 完成 **核心依赖边创建**：识别并创建 `CALLS` 和 `IMPORTS` 边（不含语义链接）。 | FR-B.2 |
| **1.5** | **输出里程碑：** 实现图结构的 **`bincode` 序列化和反序列化**，确保能快速加载。 | NFR-P.1 |

***

## 3. 阶段二：语义链接与分析引擎 🕵️

**目标：** 完成三大核心链路的链接，并实现核心的僵尸代码判定算法。

| 任务编号 | 关键任务描述 (Deliverables) | 关联需求 |
| :--- | :--- | :--- |
| **2.1** | **MyBatis 语义链接**：实现 Java 接口方法到 XML Statement 的 **`IMPLEMENTS`** 边创建逻辑。 | FR-B.3 |
| **2.2** | **存储过程 Invocation 链接**：实现 Java/脚本的字符串参数分析，创建 **`INVOKES`** 边。 | FR-B.4, FR-B.5 |
| **2.3** | **数据库表访问链接**：实现 SQL 语句解析，创建 **`ACCESSES`** 边到 `DB_Table` 节点。 | FR-B.6 |
| **2.4** | **根节点标记逻辑**：识别并标记 **`@RequestMapping`** 方法和 **`Scheduler_Script`** 文件为 **活跃根节点**。 | FR-C.1, FR-A.3 |
| **2.5** | **可达性分析算法实现**：基于 **BFS/DFS** 遍历图，标记所有不可达节点为 **`is_reachable: false`**。 | FR-C.2 |
| **2.6** | **代码考古数据提取**：为所有僵尸节点提取 **最后修改日期** 和 **贡献者**。 | FR-C.4 |

***

## 4. 阶段三：Tauri 客户端与可视化 🖥️

**目标：** 将高性能核心引擎暴露给用户，提供直观的分析结果展示。

| 任务编号 | 关键任务描述 (Deliverables) | 关联需求 |
| :--- | :--- | :--- |
| **3.1** | **Tauri 集成与 IPC 桥接**：设置 Tauri 项目，定义 Rust Core 的 **IPC API**（`run_analysis`, `get_zombie_report` 等）。 | NFR-T.2, FR-C.3 |
| **3.2** | **配置与状态视图**：构建前端，实现多仓库配置输入和项目状态展示。 | FR-D.1, FR-A.1 |
| **3.3** | **僵尸代码报告视图**：展示 **JSON 报告**，实现表格筛选（按仓库、语言、日期）和排序。 | FR-D.2 |
| **3.4** | **基础路径分析视图**：实现用户点击僵尸节点后，调用 **`query_dependencies`** IPC 命令，并使用 **D3.js** 或其他库可视化展示其**直接依赖**或**最近隔离边界**。 | FR-D.3 |
| **3.5** | **跨平台打包**：完成 CZI 客户端的 macOS 和 Windows 打包测试。 | NFR-T.4 |

***

## 5. 阶段四：性能优化与规模化 📈

**目标：** 确保系统在处理超大型代码库时的性能，并持续提升用户体验。

| 任务编号 | 关键任务描述 (Deliverables) | 关联需求 |
| :--- | :--- | :--- |
| **4.1** | **增量分析实现**：基于文件哈希值（`file_hash`）判断文件是否需要重新解析，实现 **增量图更新**。 | NFR-P.2 (提升) |
| **4.2** | **性能基准测试**：对不同规模的代码库（10万/50万/100万行）进行基准测试，优化内存分配和并发 I/O。 | NFR-P.2, NFR-P.4 |
| **4.3** | **复杂路径分析**：优化前端路径分析视图，支持展示完整的 **“死亡路径图”** 或 **“最短调用链”**。 | FR-D.3 (增强) |
| **4.4** | **错误处理与日志**：完善解析错误和 IPC 通信错误的捕获和日志记录机制。 | NFR-P.1 (稳定性) |
